"""
Обработка сетевых пакетов
Реализовать обработчик сетевых пакетов.
Вход.
Размер буфера size и число пакетов n, а так-же   две   
последовательности arrival1, . . . ,arrival n и duration1, . . . ,duration n,  
обозначающих  время  поступ-ления и длительность обработкиnпакетов.
Выход.
Для каждого из данныхnпакетов необходимовывести время начала его обработки или−1, 
если пакетне был обработан (это происходит в случае, когда пакетпоступает в момент, 
когда в буфере компьютера уженаходитсяsizeпакетов).≤size arriveprocess
Ваша цель — реализовать симу-лятор обработки сетевых пакетов.
Для i-го пакета известно время его поступленияarrivali, а также вре-мя durationi, 
необходимое на егообработку. В вашем распоряженииимеется один процессор, который
обрабатывает пакеты в порядке их поступления. Если процессор на-чинает 
обрабатывать пакетi(чтозанимает время duration i), 
он не прерывается и не останавливаетсядо тех пор, 
пока не обработает пакет.У компьютера, обрабатывающего пакеты, имеется сетевой буфер размера size. 
До начала обработки пакеты хранятся в буфере. Если бу-фер полностью заполнен в 
момент поступления пакета (естьsizeпа-кетов, поступивших ранее, которые до сих пор не обработаны), этот 
пакет отбрасывается и уже не будет обработан. 
Если несколько паке-тов поступает в одно и то же время, они все будут сперва сохранены в
буфер (несколько последних из них могут быть отброшены, если бу-фер заполнится).
Компьютер обрабатывает пакеты в порядке их поступления. Онначинает обрабатывать 
следующий пакет из буфера сразу после того,как обработает текущий пакет. Компьютер может простаивать, если11
все пакеты уже обработаны и в буфере нет пакетов. 
Пакет освобожда-ет место в буфере сразу же, как компьютер заканчивает его обработку.
Формат входа.Первая строка входа содержит размера буфераsizeи число пакевтоn. 
Каждая из следующихnстрок содержит двачисла: времяarrivaliприбытияi-го пакета и время durationi,
необходимое на его обработку. Гарантируется, что arrival1≤arrival2≤ ··· ≤arrival n. При этом может оказаться, что 
arrivali−1=arrivali. В таком случае считаем, что пакет i−1по-ступил раньше пакета i.
Формата выхода.
Для каждого изnпакетов выведите время, когда процессор начал его обрабатывать, 
или−1, если пакет был от-брошен.
Ограничения.
Все числа во входе целые.
1≤size≤105;1≤n≤105;0≤arrivali≤106;0≤durationi≤103;arrivali≤arrivali+1для всех1≤i≤n−1.
Пример.
Вход:1 0
Выход:
Если пакетов нет, выводить ничего не нужно.
Пример.
Вход:1 10 0
Выход:0
Пакет поступил в момент времени 0, и компьютер тут же началего обрабатывать.

Sample Input 1:
1 0

Sample Output 1:

Sample Input 2:
1 1
0 0

Sample Output 2:
0

Sample Input 3:
1 1
0 1

Sample Output 3:
0
"""

# Решение

def main():
    from collections import deque
    zet = deque()
    n, m = map(int, input().split())
    o = []
    for i in range(m):
        x, z = map(int, input().split())
        if len(zet) == n:
            if zet[0][1] <= x:
                if x < zet[-1][1]:
                    x = zet[-1][1]
                zet.popleft()
                zet.append([x, z + x])
                o.append(x)
            else:
                o.append(-1)
        else:
            if zet and x < zet[-1][1]:
                x = zet[-1][1]
                z += x
                zet.append([x, z])
                o.append(x)
            else:
                zet.append([x, z + x])
                o.append(x)
    print(*o, sep='\n')

if __name__ == '__main__':
    main()
