"""
Объединение таблиц
Ваша цель в данной задаче — реализовать симуляцию объединениятаблиц в базе данных.
В базе данных есть n таблиц, пронумерованных от 1 доn, над од-ним и тем же множеством столбцов (атрибутов).
Каждая таблица со-держит либо реальные записи в таблице, либо символьную ссылку надругую таблицу. 
Изначально все таблицы содержат реальные записи, и i-я таблица содержит r i записей. 
Ваша цель — обработать m запро-сов типа(destinationi,sourcei):
1. Рассмотрим таблицу с номером
destination i. Пройдясь по цепоч-ке символьных ссылок, найдём номер реальной таблицы, на ко-торую ссылается эта таблица:пока таблиц
аdestinationi содержит символическую ссылку:destinationi←symlink(destinationi)
2. Сделаем то же самое с таблицей sourcei.
3. Теперь таблицы destination i и source i содержат реальные запи-си. Если destination i 6 = source i, 
скопируем все записи из таблицы source i в таблицу destination i, очистим таблицу source i и пропи-шем в неё символическую ссылку на 
таблицу destination i.
4. Выведем максимальный размер среди всех n таблиц. 
Размеромтаблицы называется число строк в ней. Если таблица содержитсимволическую ссылку, считаем её размер равным нулю.
Формат входа.
Первая строка содержит числа n и m — число таблици число запросов, соответственно. 
Вторая строка содержит n це-лых чисел r 1, . . . , r n — размеры таблиц. 
Каждая из последующих m строк содержит два номера таблиц destination i и source i, кото-рые необходимо объединить.
Формат выхода.
Для каждого из m запросов выведите максималь-ный размер таблицы после соответствующего объединения.
Ограничения. 1≤n, m≤100 000;0≤ri≤10 000; 1 ≤ destination i, source i ≤ n.
Пример.
Вход:
5 5
1 1 1 1 1
3 5
2 4
1 4
5 4
5 3
Выход:
2
2
3
5
5
Изначально каждая таблица содержит ровно одну строку.
1. После первой операции объединения все записи из табли-цы 5 копируются в таблицу3. 
Теперь таблица 5 является ссылкой на таблицу 3, а таблица 3 содержит две записи.
2. Вторая операция аналогичным образом переносит все за-писи из таблицы 2 в таблицу 4.
3. Третья операция пытается объединить таблицы 1 и 4, нотаблица 4 ссылается на таблицу 2, 
поэтому все записи изтаблицы 2 копируются в таблицу 1. Таблица 1 теперь содер-жит три строки.
4. Чтобы произвести четвёртую операцию, проследим пути из ссылок:4→2→1и5→3. 
Скопируем все записи изтаблицы 1 в таблицу 3, после чего в таблице 3 будет пятьзаписей.
5. После этого все таблицы ссылаются на таблицу 3, поэтому все оставшиеся запросы объединения ничего не меняют.
Пример.
Вход:
6 4
10 0 5 0 3 3
6 6
6 5
5 4
4 3
Выход:
10
10
10
11
1. Запрос объединения таблицы 6 с собой ничего не меняет, максимальным размером по-прежнему остаётся 10(табли-ца1).
2. Записи из таблицы 5 копируются в таблицу 6, размер таб-лицы 6 становится равным 6.
3. Записи из таблицы 4 копируются в таблицу 6, размер таб-лицы 6 становится равным 10.
4. Записи из таблицы 3 копируются в таблицу 6, размер таб-лицы 6 становится равным 11
"""

# Решение

class DisjointSet():
    def __init__(self, i):
        self.i = i
        self.parent = self
        self.rank = 0
        self.size = i

def find(x):
    if x is not x.parent:
        x.parent = find(x.parent)
    return x.parent

def union(x, y):
    x_id, y_id = find(x), find(y)
    if x_id == y_id:
        return
    x_id.size += y_id.size
    y_id.size = x_id.size
    if x_id.rank > y_id.rank:
        y_id.parent = x_id
    else:
        x_id.parent = y_id
        if x_id.rank == y_id.rank:
            y_id.rank += 1
    return x_id.size

def main():
    a, b = map(int, input().split())
    zer = [int(i) for i in input().split()]
    mx = max(zer)
    assert len(zer) == a
    for i in range(a):
        zer[i] = DisjointSet(zer[i])
    for i in range(b):
        a, b = map(int, input().split())
        s = union(zer[a - 1], zer[b - 1])
        if s and s > mx:
            mx = s
        print(mx)


if __name__ == "__main__":
    main()
